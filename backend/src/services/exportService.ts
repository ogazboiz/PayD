import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';
import * as csv from 'fast-csv';
import { PayrollTransaction } from './payroll-indexing.service';

export class ExportService {
    /**
     * Generates a PDF receipt for a single transaction and pipes it to a stream (e.g. Express Response).
     */
    static async generateReceiptPdf(
        transaction: PayrollTransaction,
        stream: NodeJS.WritableStream
    ): Promise<void> {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({ margin: 50 });

                doc.pipe(stream);

                // Handle stream events
                stream.on('finish', () => resolve());
                stream.on('error', reject);
                doc.on('error', reject);

                // Header
                doc
                    .fillColor('#444444')
                    .fontSize(20)
                    .text('Payment Receipt', { align: 'center' })
                    .moveDown();

                doc
                    .fillColor('#000000')
                    .fontSize(10)
                    .text(`Organization: ${transaction.sourceAccount}`)
                    .text(`Employee ID: ${transaction.employeeId || 'N/A'}`)
                    .text(`Date: ${new Date(transaction.timestamp * 1000).toDateString()}`)
                    .text(`Transaction Hash: ${transaction.txHash}`)
                    .moveDown();

                // Details Table
                doc.rect(50, doc.y, 500, 20).fill('#eeeeee').stroke();
                doc.fillColor('#000000').fontSize(12);
                const startY = doc.y - 15;
                doc.text('Description', 60, startY);
                doc.text('Amount', 400, startY, { width: 90, align: 'right' });

                doc.moveDown();
                const rowY = doc.y;
                doc.fontSize(10);
                doc.text(`Salary Payment (${transaction.assetCode || 'Native'})`, 60, rowY);
                doc.text(transaction.amount || '0', 400, rowY, { width: 90, align: 'right' });

                if (transaction.memo) {
                    doc.moveDown();
                    doc.text(`Memo: ${transaction.memo}`, 60, doc.y);
                }

                // Footer
                doc.moveDown(4);
                doc.fillColor('gray').fontSize(10).text('Generated by PayD Data Export System', { align: 'center' });

                doc.end();
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Generates a multi-sheet structured Excel report of a payroll run and pipes it to a stream.
     */
    static async generatePayrollExcel(
        batchId: string,
        transactions: PayrollTransaction[],
        stream: NodeJS.WritableStream
    ): Promise<void> {
        try {
            const workbook = new ExcelJS.Workbook();
            workbook.creator = 'PayD Export System';
            workbook.created = new Date();

            const summarySheet = workbook.addWorksheet('Summary');
            summarySheet.columns = [
                { header: 'Batch ID', key: 'batchId', width: 20 },
                { header: 'Total Transactions', key: 'total', width: 20 },
                { header: 'Total Amount', key: 'sum', width: 20 },
                { header: 'Generated At', key: 'date', width: 30 },
            ];

            const sumAmount = transactions.reduce((acc, tx) => acc + parseFloat(tx.amount || '0'), 0);

            summarySheet.addRow({
                batchId,
                total: transactions.length,
                sum: sumAmount.toString(),
                date: new Date().toISOString(),
            });

            const dataSheet = workbook.addWorksheet('Transactions');
            dataSheet.columns = [
                { header: 'Transaction Hash', key: 'txHash', width: 60 },
                { header: 'Employee ID', key: 'employeeId', width: 20 },
                { header: 'Amount', key: 'amount', width: 15 },
                { header: 'Asset', key: 'assetCode', width: 15 },
                { header: 'Status', key: 'status', width: 15 },
                { header: 'Date', key: 'timestamp', width: 30 },
                { header: 'Memo', key: 'memo', width: 40 },
            ];

            transactions.forEach(tx => {
                dataSheet.addRow({
                    txHash: tx.txHash,
                    employeeId: tx.employeeId || 'N/A',
                    amount: tx.amount || '0',
                    assetCode: tx.assetCode || 'Native',
                    status: tx.successful ? 'Success' : 'Failed',
                    timestamp: new Date(tx.timestamp * 1000).toISOString(),
                    memo: tx.memo || '',
                });
            });

            // Style headers
            [summarySheet, dataSheet].forEach(sheet => {
                sheet.getRow(1).font = { bold: true };
                sheet.getRow(1).fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFE0E0E0' }
                };
            });

            await workbook.xlsx.write(stream as any);
        } catch (error) {
            throw error;
        }
    }

    /**
     * Generates a CSV report of raw transactional data and pipes it to a stream.
     */
    static async generatePayrollCsv(
        transactions: PayrollTransaction[],
        stream: NodeJS.WritableStream
    ): Promise<void> {
        return new Promise((resolve, reject) => {
            try {
                const csvStream = csv.format({ headers: true });

                stream.on('finish', () => resolve());
                stream.on('error', reject);
                csvStream.on('error', reject);

                csvStream.pipe(stream);

                transactions.forEach(tx => {
                    csvStream.write({
                        txHash: tx.txHash,
                        organizationPublicKey: tx.sourceAccount,
                        employeeId: tx.employeeId || 'N/A',
                        amount: tx.amount || '0',
                        assetCode: tx.assetCode || 'Native',
                        assetIssuer: tx.assetIssuer || '',
                        status: tx.successful ? 'Success' : 'Failed',
                        memo: tx.memo || '',
                        timestamp: new Date(tx.timestamp * 1000).toISOString()
                    });
                });

                csvStream.end();
            } catch (error) {
                reject(error);
            }
        });
    }
}
